{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CECE Downstream Problem This prototype website is intended as a collection of worked examples for faculty in CECE to use to incorporate Nature Inspired Design, Computational Thinking, and Social Technological issues into the CECE curriculum. Background The WCOE mandates a common first year experience, the three formal courses in that experience are: ENGR 1330 Computational Thinning and Data Science ENGR 1320 Biologically Inspired Design (Nature Inspired Design) ENGR 2392 Engineering Ethics and Its Impact on Society (Social Technological) Downstream use of the concepts in these course is thematically expected, and will serve to ... In searching the literature the developers found lots of philosophy and citations back to untraceable documents on the subjects (main focus on the first two) but no examples -- NONE! So this collection is a start. Audience This collection is intended for faculty to leverage concetps in the Year 1 common theme in later courses. The concept is one or two homework assignments, appropriatly chosen, where students are tasked with using the tools they developed in the first year experience. Suitable exercises are: Read and summarize a case study; identify and critique ethical conflicts, unanticipated impacts on society Convert ordinary homework problems into computational thinking exercises Identify similarities in currect design methods to nature inspired design (assuming nature is an energy minimization process) This prototype library is built on a Raspberry Pi 4 (4GB) running Ubuntu 20.XX. A complete backup is located at [github-url-here] The actual site is hosted on an AWS Lightsail Instance [fqdn-url-here]","title":"Home"},{"location":"#cece-downstream-problem","text":"This prototype website is intended as a collection of worked examples for faculty in CECE to use to incorporate Nature Inspired Design, Computational Thinking, and Social Technological issues into the CECE curriculum.","title":"CECE Downstream Problem"},{"location":"#background","text":"The WCOE mandates a common first year experience, the three formal courses in that experience are: ENGR 1330 Computational Thinning and Data Science ENGR 1320 Biologically Inspired Design (Nature Inspired Design) ENGR 2392 Engineering Ethics and Its Impact on Society (Social Technological) Downstream use of the concepts in these course is thematically expected, and will serve to ... In searching the literature the developers found lots of philosophy and citations back to untraceable documents on the subjects (main focus on the first two) but no examples -- NONE! So this collection is a start.","title":"Background"},{"location":"#audience","text":"This collection is intended for faculty to leverage concetps in the Year 1 common theme in later courses. The concept is one or two homework assignments, appropriatly chosen, where students are tasked with using the tools they developed in the first year experience. Suitable exercises are: Read and summarize a case study; identify and critique ethical conflicts, unanticipated impacts on society Convert ordinary homework problems into computational thinking exercises Identify similarities in currect design methods to nature inspired design (assuming nature is an energy minimization process) This prototype library is built on a Raspberry Pi 4 (4GB) running Ubuntu 20.XX. A complete backup is located at [github-url-here] The actual site is hosted on an AWS Lightsail Instance [fqdn-url-here]","title":"Audience"},{"location":"about/","text":"About this document This website is a collection of worked examples for instructors to illustrate how to incorporate Computational Thinking, Nature Inspired Design, and Social Technical issues into CECE Year 2-4/5 course. This prototype library is built on a Raspberry Pi 4 (4GB) running Ubuntu 20.XX. A complete backup is located at [github-url-here] The actual site is hosted on an AWS Lightsail Instance [fqdn-url-here] On-Line Library Author's Notes Inserting Code Fragments To insert a code fragment such as print('Hello World') simply indent in the source file used to generate the document print('hello world') Multiple lines Fenced code blocks are like Standard Markdown\u2019s regular code blocks, except that they\u2019re not indented and instead rely on start and end fence lines to delimit the code block. These fragments can be cut-and-paste into a JupyterLab notebook. Inserting Images If the image is taken from a URL, use the following: ![image-name (a local tag)](url_to_image_source) Such as: ![image-name](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQqn40YbupkMAzY63jYtA6auEmjRfCOvCd0FA&usqp=CAU) Which will render a black swan: If the image is local to the host replace the url with the path to the image. Inserting URL links This is a variation of images, but without the ! , such as [link-name-that-will-display](url_to_link_destimation) For example the code below will link to the black swan search results: [link-to-images-of-black-swans](https://www.google.com/search?q=images+of+black+swan&client=safari&rls=en&sxsrf=ALeKk03oIoQ387TWjJoKzX-D_b7o1to43Q:1613002985584&tbm=isch&source=iu&ictx=1&fir=L2P5MiS1ICLTxM%252CC6BDdJoXT9KcEM%252C_&vet=1&usg=AI4_-kTXrBMpj__xL5IkGCshrXTp04fX3w&sa=X&ved=2ahUKEwiCneivyODuAhVJBs0KHY88CaAQ9QF6BAgUEAE&biw=1447&bih=975#imgrc=i_lxoojURNE3XM) link-to-images-of-black-swans Inserting LaTex-like mathematical typesetting Lets try ordinary Latex mathematics first: \\begin{equation} F(x) = \\int_{-\\inf}^{x}{f(\\tau)d \\tau} \\end{equation} \\begin{equation} F(x) = \\int_{-\\inf}^{x}{f(\\tau)d \\tau} \\end{equation} then: \\begin{equation} \\delta x \\end{equation} Ok, so we don't get the eqn numbering, but we can typeset mathematics! In-line math is not working just yet \\Delta x .","title":"About"},{"location":"about/#about-this-document","text":"This website is a collection of worked examples for instructors to illustrate how to incorporate Computational Thinking, Nature Inspired Design, and Social Technical issues into CECE Year 2-4/5 course. This prototype library is built on a Raspberry Pi 4 (4GB) running Ubuntu 20.XX. A complete backup is located at [github-url-here] The actual site is hosted on an AWS Lightsail Instance [fqdn-url-here]","title":"About this document"},{"location":"about/#on-line-library-authors-notes","text":"Inserting Code Fragments To insert a code fragment such as print('Hello World') simply indent in the source file used to generate the document print('hello world') Multiple lines Fenced code blocks are like Standard Markdown\u2019s regular code blocks, except that they\u2019re not indented and instead rely on start and end fence lines to delimit the code block. These fragments can be cut-and-paste into a JupyterLab notebook. Inserting Images If the image is taken from a URL, use the following: ![image-name (a local tag)](url_to_image_source) Such as: ![image-name](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQqn40YbupkMAzY63jYtA6auEmjRfCOvCd0FA&usqp=CAU) Which will render a black swan: If the image is local to the host replace the url with the path to the image. Inserting URL links This is a variation of images, but without the ! , such as [link-name-that-will-display](url_to_link_destimation) For example the code below will link to the black swan search results: [link-to-images-of-black-swans](https://www.google.com/search?q=images+of+black+swan&client=safari&rls=en&sxsrf=ALeKk03oIoQ387TWjJoKzX-D_b7o1to43Q:1613002985584&tbm=isch&source=iu&ictx=1&fir=L2P5MiS1ICLTxM%252CC6BDdJoXT9KcEM%252C_&vet=1&usg=AI4_-kTXrBMpj__xL5IkGCshrXTp04fX3w&sa=X&ved=2ahUKEwiCneivyODuAhVJBs0KHY88CaAQ9QF6BAgUEAE&biw=1447&bih=975#imgrc=i_lxoojURNE3XM) link-to-images-of-black-swans Inserting LaTex-like mathematical typesetting Lets try ordinary Latex mathematics first: \\begin{equation} F(x) = \\int_{-\\inf}^{x}{f(\\tau)d \\tau} \\end{equation} \\begin{equation} F(x) = \\int_{-\\inf}^{x}{f(\\tau)d \\tau} \\end{equation} then: \\begin{equation} \\delta x \\end{equation} Ok, so we don't get the eqn numbering, but we can typeset mathematics! In-line math is not working just yet \\Delta x .","title":"On-Line Library Author's Notes"},{"location":"developer-notes/","text":"Hardware Requirements This prototype library is built on a Raspberry Pi 4 (4GB) running Ubuntu 20.XX. Substantial configuration and build-from-source is involved to get Latex-like rendering and useable code blocks working. A complete backup is located at [github-url-here] The actual public site is hosted on an AWS Lightsail Instance [http://54.243.252.9/cece-dev-databases/LibrarySolutionsForCT/site/] Developer Notes Inserting Code Fragments To insert a code fragment such as print('Hello World') simply indent in the source file used to generate the document print('hello world') Multiple lines use fenced blocks. These blocks are theme dependent. Fenced code blocks are like Standard Markdown\u2019s regular code blocks, except that they\u2019re not indented and instead rely on start and end fence lines to delimit the code block. These fragments can be cut-and-paste into a JupyterLab notebook. Inserting Images If the image is taken from a URL, use the following: ![image-name (a local tag)](url_to_image_source) Such as: ![image-name](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQqn40YbupkMAzY63jYtA6auEmjRfCOvCd0FA&usqp=CAU) Which will render a black swan: If the image is local to the host replace the url with the path to the image. Inserting URL links This is a variation of images, but without the ! , such as [link-name-that-will-display](url_to_link_destimation) For example the code below will link to the black swan search results: [link-to-images-of-black-swans](https://www.google.com/search?q=images+of+black+swan&client=safari&rls=en&sxsrf=ALeKk03oIoQ387TWjJoKzX-D_b7o1to43Q:1613002985584&tbm=isch&source=iu&ictx=1&fir=L2P5MiS1ICLTxM%252CC6BDdJoXT9KcEM%252C_&vet=1&usg=AI4_-kTXrBMpj__xL5IkGCshrXTp04fX3w&sa=X&ved=2ahUKEwiCneivyODuAhVJBs0KHY88CaAQ9QF6BAgUEAE&biw=1447&bih=975#imgrc=i_lxoojURNE3XM) link-to-images-of-black-swans Inserting LaTex-like Mathematics Lets try ordinary Latex mathematics first: \\begin{equation} F(x) = \\int_{-\\inf}^{x}{f(\\tau)d \\tau} \\end{equation} \\begin{equation} F(x) = \\int_{-\\inf}^{x}{f(\\tau)d \\tau} \\end{equation} then: \\begin{equation} \\delta x \\end{equation} Ok, so we don't get the eqn numbering, but we can typeset mathematics! In-line math is not working just yet \\Delta x , need to build from source becaue ubuntu package is not current.","title":"Developer"},{"location":"developer-notes/#hardware-requirements","text":"This prototype library is built on a Raspberry Pi 4 (4GB) running Ubuntu 20.XX. Substantial configuration and build-from-source is involved to get Latex-like rendering and useable code blocks working. A complete backup is located at [github-url-here] The actual public site is hosted on an AWS Lightsail Instance [http://54.243.252.9/cece-dev-databases/LibrarySolutionsForCT/site/]","title":"Hardware Requirements"},{"location":"developer-notes/#developer-notes","text":"","title":"Developer Notes"},{"location":"developer-notes/#inserting-code-fragments","text":"To insert a code fragment such as print('Hello World') simply indent in the source file used to generate the document print('hello world') Multiple lines use fenced blocks. These blocks are theme dependent. Fenced code blocks are like Standard Markdown\u2019s regular code blocks, except that they\u2019re not indented and instead rely on start and end fence lines to delimit the code block. These fragments can be cut-and-paste into a JupyterLab notebook.","title":"Inserting Code Fragments"},{"location":"developer-notes/#inserting-images","text":"If the image is taken from a URL, use the following: ![image-name (a local tag)](url_to_image_source) Such as: ![image-name](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQqn40YbupkMAzY63jYtA6auEmjRfCOvCd0FA&usqp=CAU) Which will render a black swan: If the image is local to the host replace the url with the path to the image. Inserting URL links This is a variation of images, but without the ! , such as [link-name-that-will-display](url_to_link_destimation) For example the code below will link to the black swan search results: [link-to-images-of-black-swans](https://www.google.com/search?q=images+of+black+swan&client=safari&rls=en&sxsrf=ALeKk03oIoQ387TWjJoKzX-D_b7o1to43Q:1613002985584&tbm=isch&source=iu&ictx=1&fir=L2P5MiS1ICLTxM%252CC6BDdJoXT9KcEM%252C_&vet=1&usg=AI4_-kTXrBMpj__xL5IkGCshrXTp04fX3w&sa=X&ved=2ahUKEwiCneivyODuAhVJBs0KHY88CaAQ9QF6BAgUEAE&biw=1447&bih=975#imgrc=i_lxoojURNE3XM) link-to-images-of-black-swans","title":"Inserting  Images"},{"location":"developer-notes/#inserting-latex-like-mathematics","text":"Lets try ordinary Latex mathematics first: \\begin{equation} F(x) = \\int_{-\\inf}^{x}{f(\\tau)d \\tau} \\end{equation} \\begin{equation} F(x) = \\int_{-\\inf}^{x}{f(\\tau)d \\tau} \\end{equation} then: \\begin{equation} \\delta x \\end{equation} Ok, so we don't get the eqn numbering, but we can typeset mathematics! In-line math is not working just yet \\Delta x , need to build from source becaue ubuntu package is not current.","title":"Inserting LaTex-like Mathematics"},{"location":"hydrology/","text":"Hydrology This is currently a placeholder file, a suitable example problem would be to deconvolve a rainfall-runoff signal and parameterize a response kernel (unit hydrograph) , provided input precipitation and output runoff. The example would contain links to a database with training events, then a few challenge events. Entire problem can be done in JupyterLab/Python as per WCOE vision. Check Typeset \\begin{equation} Q(t) = A \\cdot \\int_{0}^{t}{P(t-\\tau)U(\\tau)d \\tau} \\end{equation}","title":"Hydrology"},{"location":"hydrology/#hydrology","text":"This is currently a placeholder file, a suitable example problem would be to deconvolve a rainfall-runoff signal and parameterize a response kernel (unit hydrograph) , provided input precipitation and output runoff. The example would contain links to a database with training events, then a few challenge events. Entire problem can be done in JupyterLab/Python as per WCOE vision.","title":"Hydrology"},{"location":"hydrology/#check-typeset","text":"\\begin{equation} Q(t) = A \\cdot \\int_{0}^{t}{P(t-\\tau)U(\\tau)d \\tau} \\end{equation}","title":"Check Typeset"},{"location":"placeholder/","text":"Placeholder file Replace with content, then update the index page, recompile and serve","title":"Placeholder file"},{"location":"placeholder/#placeholder-file","text":"Replace with content, then update the index page, recompile and serve","title":"Placeholder file"},{"location":"fluids/fluids/","text":"How to make an ordinary homework problem into a computational thinking exercise - Fluid Mechanics Prerequesites (for this example) Students will have completed ENGR-1330; CE 2301; and be enrolled in CE 3305 Students (by virtue of ENGR-1330) will have functioning implementations of JupyterLab Methodology for Problem (and Solution) Present problem verbatim from usual source, i.e. textbook Review main principles of CT : Algorithm - A list of steps that you can follow to finish a task Decomposition - Break a problem down into smaller pieces Abstraction - Pulling out specific differences to make one solution work for multiple problems Pattern Matching - Finding similarities between things CT Problem Solving Protocol (from ENGR-1330) Explicitly state the problem State: Input information Governing equations or principles, and The required output information. Work a sample problem by-hand for testing the general solution. Develop a general solution method (coding). Test the general solution against the by-hand example, then apply to the real problem. Start the problem/solution example; explicitly identify CT principles as problem proceedes. Choose meaningful problems Problem Statement (Cite Source) Jet-type pumps are often used for special applications, such as to circulate the flow in basins in which fish are farmed. The use of a jet-pump reduces mechanical injury to the fish. Figures 1 and 2 show the basic concept for this application of a jet pump. Figure 1 Plan View of a fish race Figure 2 Elevation detail of a fish race jet pump For this type of basin the jets would have to increase the water surface elevation by an amount equal to \\frac{6V^2}{2g} , where V is the average velocity in the basin ( 1~\\frac{ft}{s} as shown in the figures). Propose a basic design for a jet system that would make such a recirculating system work for a channel 8 ft wide and 4 ft deep. That is determine the nozzle diameter, speed, and number of nozzles. The design should specify nominal diameters of nozzles using commercially available pipes (1-in., 2-in, ...). How do the specifications change if the desired water depth is to be 6 feet deep (to accomodate more fish) Hint This problem involves \"analysis\" to determine the required momentum added by the jets and the total jet area and speed The design should be based on this analysis with an understanding that the total jet area should be small as compared to the total flow area (otherwise the fish could get stuck!). Problem Solving Protocol Recall the problem solving protocols in ENGR-1330 https://3.137.111.182/engr-1330-webroot/1-Lessons/Lesson02/OriginalPowerpoint/ENGR-1330-Lesson2.html Define the problem (problem statement) Gather information (identify known and unknown values, and governing equations) Generate and evaluate potential solutions Refine and implement a solution Verify and test the solution. We can stipulate that Step 1 is already done, Known Values: Geometry Liquid (Water) ( if we need properties we can get them from http://theodore-odroid.ttu.edu/documents/toolbox/fluidmechanics/WaterPropertiesUS/WaterPropertiesUS.html , or something similar Unknown Values Jet diameter Jet speed Jet count (number of jets) Governing Principles These are going to be problem and discipline specific; in this case conservation of mass and momentum are going to be required. Abstraction -- The Control Volume Diagram At this point we are mostly trying to develop an algorithm, but are already about to apply abstraction when we create a Control-Volume Diagram of the mixing zone depicted in Figure 2. Figure 3 Control Volume Diagram of Mixing Zone Examining the diagram, we will further abstract by defining variables for our problem: \\begin{gather} \\end{gather} <script type=\"math/tex; mode=display\">\\begin{gather} \\begin{aligned} & F_1 == \\text{Pressure force on approach face of mixing zone } \\\\ & F_2 == \\text{Pressure force on exit face of mixing zone } \\\\ & u_1 == \\text{Free stream speed on approach face of mixing zone} \\\\ & u_2 == \\text{Free stream speed on exit face of mixing zone } \\\\ & u_j == \\text{Jet stream speed in mixing zone } \\\\ & A_1 == \\text{Free stream area of approach face of mixing zone } \\\\ & A_2 == \\text{Free stream ares of exit face of mixing zone } \\\\ & A_j == \\text{Jet stream speed in mixing zone } \\\\ \\end{aligned} \\end{gather} Decomposition - Continunity Analysis Recall the continunity result from the Reynolds Transport Theorem: 0 = \\frac{\\partial}{\\partial t}\\int_{CV} \\rho dV + \\int_{CS} \\rho(V \\cdot dA) Substitute the geometry from the problem conditions into the flux integral (the volume integral vanishes because we are considering steady flow) as 0 = \\rho u_2 A_2 - \\rho u_1 A_1 - \\rho u_j A_j where ~~~~~A_1 = W \\cdot (y_1 - \\Delta y) ~~~~~A_2 = W \\cdot (y_2) ~~~~~A_j = W \\cdot (\\Delta y) ~~~~~W = \\text{width of channel} Notice that if the channel is a constant width, and we stipulate that the liquid is incompressible so that the density is some constant, we can factor these out to obtain 0= u_2 \\cdot (y_2) - u_1 \\cdot (y_1 - \\Delta y) - u_j \\cdot (\\Delta y) Rewrite in terms of u_2 as: u_2 \\cdot (y_2) = u_1 \\cdot (y_1 - \\Delta y) + u_j \\cdot (\\Delta y) Divide by y_2 to obtain u_2 (which we will substitute into momentum shortly!) u_2 = \\frac{u_1 \\cdot (y_1 - \\Delta y) + u_j \\cdot (\\Delta y)}{y_2} Decomposition - Momentum Analysis Recall the momentum result from the Reynolds Transport Theorem: \\sum F_x = \\frac{\\partial}{\\partial t}\\int_{CV} V \\rho dV + \\int_{CS} V\\rho(V \\cdot dA) Consider force diffference: F_1 - F_2 = -u_j~\\rho~u_j A_j - u_1 \\rho u_1 A_1 + u_2 \\rho u_2 A_2 where ~~~~~A_1 = W \\cdot (y_1 - \\Delta y) ~~~~~A_2 = W \\cdot (y_2) ~~~~~A_j = W \\cdot (\\Delta y) ~~~~~W = \\text{width of channel} Stipulate hydrostatic pressure forces at upstream and downstream faces F_1 = \\rho g \\frac{y_1}{2} y_1 W F_2 = \\rho g \\frac{y_2}{2} y_2 W Now substitute into the momentum balance for the control volume \\rho g W (\\frac{y_1^2}{2} - \\frac{y_2^2}{2}) = -u_j~\\rho~u_j W \\cdot (\\Delta y) - u_1 \\rho u_1 W \\cdot (y_1 - \\Delta y) + u_2 \\rho u_2 W \\cdot (y_2) Notice that if the channel is a constant width, and we stipulate that the liquid is incompressible so that the density is some constant, we can factor these out to obtain g (\\frac{y_1^2}{2} - \\frac{y_2^2}{2}) = -u_j~u_j \\cdot (\\Delta y) - u_1 u_1 \\cdot (y_1 - \\Delta y) + u_2 u_2 \\cdot (y_2) Now arrange momentum in terms of the jet as u_j^2 ~\\Delta y = - u_1^2(y_1 - ~ \\Delta y) + u_2^2~y_2 - \\frac{g}{2}(y_1^2 - y_2^2) Substitute u_2 from continunity u_j^2 ~\\Delta y = - u_1^2(y_1 - ~ \\Delta y) + [\\frac{ u_1~(y_1 - ~ \\Delta y) - u_j ~\\Delta y}{y_2}]^2~y_2 - \\frac{g}{2}[y_1^2 - y_2^2] This equation is our model, it is implicit in u_j^2 ~\\Delta y , hence almost requires a computational approach to find a solution. As a first step, lets try a predictor-correction approach - that is we will simply guess values for cetrain unknowns, and see how close we can make thw two sides of the model agree. Guess-Check-Refine Approach Verify what we know about the problem: u_1 = 1 \\text{ft/sec (given)} y_1 = 4 \\text{ft (given)} y_2 = 4 + \\frac{6(1)^2}{2(32.2)} = 4.0932 \\text{ft (indirectly given)} u_2 = f(u_j,\\Delta y) \\text{ (model equation)} u_j = \\text{unknown} \\Delta y = \\text{unknown} g = 32.2 \\text{ft/sec/sec (given)} Keep in mind that \\Delta y is proportional to the jet area, and the jets are small (unless we want to make our facility into a Bass-o-Matic https://www.youtube.com/watch?v=c06HorsmhjY We will rearrange our model equation above, by dividing by \\Delta y u_j^2 = \\frac{- u_1^2(y_1 - ~ \\Delta y) + [\\frac{ u_1~(y_1 - ~ \\Delta y) - u_j ~\\Delta y}{y_2}]^2~y_2 - \\frac{g}{2}[y_1^2 - y_2^2]}{\\Delta y} Then gather all the terms involving u_j onto the left hand side as u_j^2 - \\frac{u_j^2 \\Delta y}{y_2} + \\frac{2 u_1 (y_1 - \\Delta y)}{y_2} = \\frac{- u_1^2(y_1 - ~ \\Delta y)}{\\Delta y} + \\frac{u_1^2 (y_1 - \\Delta y)^2}{y_2 \\Delta y} - \\frac{g}{2 \\Delta y}[y_1^2 - y_2^2] Now we are ready for computation - if we \"pick\" \\Delta y the only unknown is u_j ; therefore solvable. If we make a set of guesses, we can compute required jet speed and jet total area. First some preliminary coding, to use different jet speeds for a given \\Delta y dy = 0.1 #delta y width = 8.0 grav = 32.2 # gravitational acceleration constant (US Customary Units) u1 = 1.0 #free stream approach y1 = 4.0 #approach depth y2 = y1 + 6.0*(u1**2)/(2.0*grav) rhs = -u1*u1*(y1-dy)/dy + (u1*u1*(y1-dy)**2)/(y2*dy) - grav*(y1**2-y2**2)/(2*dy) for i in range(1,200): uj = float(i)*0.1 lhs = uj**2*(1-dy/y2) + 2*u1*(y1-dy)*uj/y2 if abs(lhs-rhs) <=2: #only print when close print('uj = ',round(uj,2),'LHS = ',round(lhs,2),'RHS = ',round(rhs,2)) uj = 10.1 LHS = 118.76 RHS = 119.56 uj = 10.2 LHS = 120.94 RHS = 119.56 So for a \\Delta y of 0.1, the required jet speed is somewhere around 10.1 feet per second. Now we need to determine the total jet area, and nominal sizes. areajet = dy*width import math def howManyJets(jetarea,diameter): perjet = 0.25*math.pi*diameter**2 if jetarea%perjet == 0: howManyJets = jetarea/perjet elif jetarea%perjet != 0: howManyJets = jetarea//perjet + 1 return howManyJets inches = 1/12 howManyJets(areajet,inches) 147.0 So for \\Delta y of 0.1 we will need 147 1-inch diameter jets. The next step is to refine and generalize our solution so we can explore different speeds - for example a 10 ft/sec jet will probably skin a fish, not healthy for our application. For refinement, lets improve the precision of the jet speed calculation (i.e. automate the matching of lhs and rhs) More to come References list them here, link where possible list them here, link where possible list them here, link where possible","title":"Fluids"},{"location":"fluids/fluids/#how-to-make-an-ordinary-homework-problem-into-a-computational-thinking-exercise-fluid-mechanics","text":"","title":"How to make an ordinary homework problem into a computational thinking exercise - Fluid Mechanics"},{"location":"fluids/fluids/#prerequesites-for-this-example","text":"Students will have completed ENGR-1330; CE 2301; and be enrolled in CE 3305 Students (by virtue of ENGR-1330) will have functioning implementations of JupyterLab","title":"Prerequesites (for this example)"},{"location":"fluids/fluids/#methodology-for-problem-and-solution","text":"Present problem verbatim from usual source, i.e. textbook Review main principles of CT : Algorithm - A list of steps that you can follow to finish a task Decomposition - Break a problem down into smaller pieces Abstraction - Pulling out specific differences to make one solution work for multiple problems Pattern Matching - Finding similarities between things CT Problem Solving Protocol (from ENGR-1330) Explicitly state the problem State: Input information Governing equations or principles, and The required output information. Work a sample problem by-hand for testing the general solution. Develop a general solution method (coding). Test the general solution against the by-hand example, then apply to the real problem. Start the problem/solution example; explicitly identify CT principles as problem proceedes. Choose meaningful problems","title":"Methodology for Problem (and Solution)"},{"location":"fluids/fluids/#problem-statement-cite-source","text":"Jet-type pumps are often used for special applications, such as to circulate the flow in basins in which fish are farmed. The use of a jet-pump reduces mechanical injury to the fish. Figures 1 and 2 show the basic concept for this application of a jet pump. Figure 1 Plan View of a fish race Figure 2 Elevation detail of a fish race jet pump For this type of basin the jets would have to increase the water surface elevation by an amount equal to \\frac{6V^2}{2g} , where V is the average velocity in the basin ( 1~\\frac{ft}{s} as shown in the figures). Propose a basic design for a jet system that would make such a recirculating system work for a channel 8 ft wide and 4 ft deep. That is determine the nozzle diameter, speed, and number of nozzles. The design should specify nominal diameters of nozzles using commercially available pipes (1-in., 2-in, ...). How do the specifications change if the desired water depth is to be 6 feet deep (to accomodate more fish) Hint This problem involves \"analysis\" to determine the required momentum added by the jets and the total jet area and speed The design should be based on this analysis with an understanding that the total jet area should be small as compared to the total flow area (otherwise the fish could get stuck!).","title":"Problem Statement (Cite Source)"},{"location":"fluids/fluids/#problem-solving-protocol","text":"Recall the problem solving protocols in ENGR-1330 https://3.137.111.182/engr-1330-webroot/1-Lessons/Lesson02/OriginalPowerpoint/ENGR-1330-Lesson2.html Define the problem (problem statement) Gather information (identify known and unknown values, and governing equations) Generate and evaluate potential solutions Refine and implement a solution Verify and test the solution. We can stipulate that Step 1 is already done,","title":"Problem Solving Protocol"},{"location":"fluids/fluids/#known-values","text":"Geometry Liquid (Water) ( if we need properties we can get them from http://theodore-odroid.ttu.edu/documents/toolbox/fluidmechanics/WaterPropertiesUS/WaterPropertiesUS.html , or something similar","title":"Known Values:"},{"location":"fluids/fluids/#unknown-values","text":"Jet diameter Jet speed Jet count (number of jets)","title":"Unknown Values"},{"location":"fluids/fluids/#governing-principles","text":"These are going to be problem and discipline specific; in this case conservation of mass and momentum are going to be required.","title":"Governing Principles"},{"location":"fluids/fluids/#abstraction-the-control-volume-diagram","text":"At this point we are mostly trying to develop an algorithm, but are already about to apply abstraction when we create a Control-Volume Diagram of the mixing zone depicted in Figure 2. Figure 3 Control Volume Diagram of Mixing Zone Examining the diagram, we will further abstract by defining variables for our problem: \\begin{gather} \\end{gather} <script type=\"math/tex; mode=display\">\\begin{gather} \\begin{aligned} & F_1 == \\text{Pressure force on approach face of mixing zone } \\\\ & F_2 == \\text{Pressure force on exit face of mixing zone } \\\\ & u_1 == \\text{Free stream speed on approach face of mixing zone} \\\\ & u_2 == \\text{Free stream speed on exit face of mixing zone } \\\\ & u_j == \\text{Jet stream speed in mixing zone } \\\\ & A_1 == \\text{Free stream area of approach face of mixing zone } \\\\ & A_2 == \\text{Free stream ares of exit face of mixing zone } \\\\ & A_j == \\text{Jet stream speed in mixing zone } \\\\ \\end{aligned} \\end{gather}","title":"Abstraction -- The Control Volume Diagram"},{"location":"fluids/fluids/#decomposition-continunity-analysis","text":"Recall the continunity result from the Reynolds Transport Theorem: 0 = \\frac{\\partial}{\\partial t}\\int_{CV} \\rho dV + \\int_{CS} \\rho(V \\cdot dA) Substitute the geometry from the problem conditions into the flux integral (the volume integral vanishes because we are considering steady flow) as 0 = \\rho u_2 A_2 - \\rho u_1 A_1 - \\rho u_j A_j where ~~~~~A_1 = W \\cdot (y_1 - \\Delta y) ~~~~~A_2 = W \\cdot (y_2) ~~~~~A_j = W \\cdot (\\Delta y) ~~~~~W = \\text{width of channel} Notice that if the channel is a constant width, and we stipulate that the liquid is incompressible so that the density is some constant, we can factor these out to obtain 0= u_2 \\cdot (y_2) - u_1 \\cdot (y_1 - \\Delta y) - u_j \\cdot (\\Delta y) Rewrite in terms of u_2 as: u_2 \\cdot (y_2) = u_1 \\cdot (y_1 - \\Delta y) + u_j \\cdot (\\Delta y) Divide by y_2 to obtain u_2 (which we will substitute into momentum shortly!) u_2 = \\frac{u_1 \\cdot (y_1 - \\Delta y) + u_j \\cdot (\\Delta y)}{y_2}","title":"Decomposition - Continunity Analysis"},{"location":"fluids/fluids/#decomposition-momentum-analysis","text":"Recall the momentum result from the Reynolds Transport Theorem: \\sum F_x = \\frac{\\partial}{\\partial t}\\int_{CV} V \\rho dV + \\int_{CS} V\\rho(V \\cdot dA) Consider force diffference: F_1 - F_2 = -u_j~\\rho~u_j A_j - u_1 \\rho u_1 A_1 + u_2 \\rho u_2 A_2 where ~~~~~A_1 = W \\cdot (y_1 - \\Delta y) ~~~~~A_2 = W \\cdot (y_2) ~~~~~A_j = W \\cdot (\\Delta y) ~~~~~W = \\text{width of channel} Stipulate hydrostatic pressure forces at upstream and downstream faces F_1 = \\rho g \\frac{y_1}{2} y_1 W F_2 = \\rho g \\frac{y_2}{2} y_2 W Now substitute into the momentum balance for the control volume \\rho g W (\\frac{y_1^2}{2} - \\frac{y_2^2}{2}) = -u_j~\\rho~u_j W \\cdot (\\Delta y) - u_1 \\rho u_1 W \\cdot (y_1 - \\Delta y) + u_2 \\rho u_2 W \\cdot (y_2) Notice that if the channel is a constant width, and we stipulate that the liquid is incompressible so that the density is some constant, we can factor these out to obtain g (\\frac{y_1^2}{2} - \\frac{y_2^2}{2}) = -u_j~u_j \\cdot (\\Delta y) - u_1 u_1 \\cdot (y_1 - \\Delta y) + u_2 u_2 \\cdot (y_2) Now arrange momentum in terms of the jet as u_j^2 ~\\Delta y = - u_1^2(y_1 - ~ \\Delta y) + u_2^2~y_2 - \\frac{g}{2}(y_1^2 - y_2^2) Substitute u_2 from continunity u_j^2 ~\\Delta y = - u_1^2(y_1 - ~ \\Delta y) + [\\frac{ u_1~(y_1 - ~ \\Delta y) - u_j ~\\Delta y}{y_2}]^2~y_2 - \\frac{g}{2}[y_1^2 - y_2^2] This equation is our model, it is implicit in u_j^2 ~\\Delta y , hence almost requires a computational approach to find a solution. As a first step, lets try a predictor-correction approach - that is we will simply guess values for cetrain unknowns, and see how close we can make thw two sides of the model agree.","title":"Decomposition - Momentum Analysis"},{"location":"fluids/fluids/#guess-check-refine-approach","text":"Verify what we know about the problem: u_1 = 1 \\text{ft/sec (given)} y_1 = 4 \\text{ft (given)} y_2 = 4 + \\frac{6(1)^2}{2(32.2)} = 4.0932 \\text{ft (indirectly given)} u_2 = f(u_j,\\Delta y) \\text{ (model equation)} u_j = \\text{unknown} \\Delta y = \\text{unknown} g = 32.2 \\text{ft/sec/sec (given)} Keep in mind that \\Delta y is proportional to the jet area, and the jets are small (unless we want to make our facility into a Bass-o-Matic https://www.youtube.com/watch?v=c06HorsmhjY We will rearrange our model equation above, by dividing by \\Delta y u_j^2 = \\frac{- u_1^2(y_1 - ~ \\Delta y) + [\\frac{ u_1~(y_1 - ~ \\Delta y) - u_j ~\\Delta y}{y_2}]^2~y_2 - \\frac{g}{2}[y_1^2 - y_2^2]}{\\Delta y} Then gather all the terms involving u_j onto the left hand side as u_j^2 - \\frac{u_j^2 \\Delta y}{y_2} + \\frac{2 u_1 (y_1 - \\Delta y)}{y_2} = \\frac{- u_1^2(y_1 - ~ \\Delta y)}{\\Delta y} + \\frac{u_1^2 (y_1 - \\Delta y)^2}{y_2 \\Delta y} - \\frac{g}{2 \\Delta y}[y_1^2 - y_2^2] Now we are ready for computation - if we \"pick\" \\Delta y the only unknown is u_j ; therefore solvable. If we make a set of guesses, we can compute required jet speed and jet total area. First some preliminary coding, to use different jet speeds for a given \\Delta y dy = 0.1 #delta y width = 8.0 grav = 32.2 # gravitational acceleration constant (US Customary Units) u1 = 1.0 #free stream approach y1 = 4.0 #approach depth y2 = y1 + 6.0*(u1**2)/(2.0*grav) rhs = -u1*u1*(y1-dy)/dy + (u1*u1*(y1-dy)**2)/(y2*dy) - grav*(y1**2-y2**2)/(2*dy) for i in range(1,200): uj = float(i)*0.1 lhs = uj**2*(1-dy/y2) + 2*u1*(y1-dy)*uj/y2 if abs(lhs-rhs) <=2: #only print when close print('uj = ',round(uj,2),'LHS = ',round(lhs,2),'RHS = ',round(rhs,2)) uj = 10.1 LHS = 118.76 RHS = 119.56 uj = 10.2 LHS = 120.94 RHS = 119.56 So for a \\Delta y of 0.1, the required jet speed is somewhere around 10.1 feet per second. Now we need to determine the total jet area, and nominal sizes. areajet = dy*width import math def howManyJets(jetarea,diameter): perjet = 0.25*math.pi*diameter**2 if jetarea%perjet == 0: howManyJets = jetarea/perjet elif jetarea%perjet != 0: howManyJets = jetarea//perjet + 1 return howManyJets inches = 1/12 howManyJets(areajet,inches) 147.0 So for \\Delta y of 0.1 we will need 147 1-inch diameter jets. The next step is to refine and generalize our solution so we can explore different speeds - for example a 10 ft/sec jet will probably skin a fish, not healthy for our application. For refinement, lets improve the precision of the jet speed calculation (i.e. automate the matching of lhs and rhs) More to come","title":"Guess-Check-Refine Approach"},{"location":"fluids/fluids/#references","text":"list them here, link where possible list them here, link where possible list them here, link where possible","title":"References"},{"location":"statics/statics/","text":"%%html <!--Script block to left align Markdown Tables--> <style> table {margin-left: 0 !important;} </style> table {margin-left: 0 !important;} Making an ordinary homework problem into a computational thinking exercise Engineering Mechanics (Statics) Prerequesites (for this example) Students will have completed ENGR-1330; CE 2301; and be enrolled in CE 2301 Students (by virtue of ENGR-1330) will have functioning implementations of JupyterLab Methodology for Problem (and Solution) Present problem verbatim from usual source, i.e. textbook Review main principles of CT : Algorithm - A list of steps that you can follow to finish a task Decomposition - Break a problem down into smaller pieces Abstraction - Pulling out specific differences to make one solution work for multiple problems Pattern Matching - Finding similarities between things CT Problem Solving Protocol (from ENGR-1330) Explicitly state the problem State: Input information Governing equations or principles, and The required output information. Work a sample problem by-hand for testing the general solution. Develop a general solution method (coding). Test the general solution against the by-hand example, then apply to the real problem. Start the problem/solution example; explicitly identify CT principles as problem proceedes. Choose meaningful problems A typical static truss analysis problem goes like \"The figure below is a simply supported, statically determinate truss with pin connections (zero moment transfer connections). Find the forces in each member for the loading shown.\" This example will leverage linear systems solver(s) to analyze the truss. The approach uses concepts from statics and computational thinking. From statics method of joints (for reactions and internal forcez) direction cosines From computational thinking read input file construct linear system \\textbf{Ax=b} ; solve for \\textbf{x} report results Problem Solving Protocol Recall the problem solving protocols in ENGR-1330-S2021-Cleveland Define the problem (problem statement) Gather information (identify known and unknown values, and governing equations) Generate and evaluate potential solutions Refine and implement a solution Verify and test the solution. We can stipulate that Step 1 is already done, Known Values: Geometry (angles, not necessarily the mamber lengths and (x,y,z) coordinates of the junctions. External loads Unknown Values Support reactions Member forces Governing Principles These are going to be problem and discipline specific; in this case two-force memebrs are assumed (stipulated), and the network is statically determinate. The ability to construct and find solutions to a non-singular linear system is assumed. The solution of linear systems is presented in ENGR-1330 in the following contexts: Linear Algebra using Numpy ENGR-1330-S2021-Cleveland Data Modeling: Regression Approach (Specifically, the later part of the lesson performs regression by solving linear systems entirely using python primatives) ENGR-1330-S2021-Cleveland Whatever students get in Calculus at this point Abstraction -- The Free-Body Diagram Before even contemplating writing/using a program we need to build a mathematical model of the truss and assemble the system of linear equations that result from the model. A fundamental abstraction is to sketch a free-body-diagram as below and build a node naming convention (a type of pattern matching ) and force names( abstraction with intent to replicate/ automate ). Decomposition -- Node-by-Node Analysis Next we will write the force balance for each of the six nodes ( N1 - N6 ), which will produce a total of 12 equations in the 12 unknowns (the 9 member forces, and 3 reactions). This is fundamentally a decomposition activity. While specific to this geometry, we could extend the analysis to allow for an external force at all nodes considered, and be able to solve for nearly any loading condition. The figure below is the force balance for node N1 , the two force equations (for the horizontal, x , direction and the vertical, y , direction) are listed below the figure. \\begin{gather} \\begin{matrix} \\sum F_x = 0 = & +F_1cos(45) & + F_2 & & & & & & & + A_x & & & & & \\\\ \\sum F_y = 0 = & +F_1sin(45) & & & & & & & & & & + A_y & & & \\\\ \\end{matrix} \\end{gather} The equation above is the force balance equation pair for the node. The x component equation will later be named N1_x to indicate it arises from Node 1, x component equation. A similar notation convention will also be adopted for the y component equation. There will be an equation pair for each node. Below is a sketch of the force balance for node N2 , the two force equations (for the horizontal, x , direction and the vertical, y , direction) are listed below the figure. \\begin{gather} \\begin{matrix} \\sum F_x = 0 = & & -F_2 & & & & +F_6 & & & & & & & & \\\\ \\sum F_y = 0 = & & & +F_3 & & & & & & & & & & & \\\\ \\end{matrix} \\end{gather} Below is a sketch of the force balance for node N3 , the two force equations (for the horizontal, x , direction and the vertical, y , direction) are listed below the figure. \\begin{gather} \\begin{matrix} \\sum F_x = 0 = & & & & & -F_5cos(30) & -F_6 & & +F_8 & & & & & & \\\\ \\sum F_y = 0 = & & & & & F_5sin(30) & & +F_7 & & & & & & & -P_3\\\\ \\end{matrix} \\end{gather} Above is the force balance equation pair for node N3 . Below is a sketch of the force balance for node N4 , the two force equations (for the horizontal, x , direction and the vertical, y , direction) are listed below the figure. \\begin{gather} \\begin{matrix} \\sum F_x = 0 = & & & & & & & & -F_8 & -F_9cos(45) & & & & & \\\\ \\sum F_y = 0 = & & & & & & & & & F_9sin(45) & & & +B_y & & \\\\ \\end{matrix} \\end{gather} Above is the force balance equation pair for node N4 . Below is a sketch of the force balance for node N5 , the two force equations (for the horizontal, x , direction and the vertical, y , direction) are listed below the figure. \\begin{gather} \\begin{matrix} \\sum F_x = 0 = & -F_1cos(45) & & & +F_4 & +F_5cos(30) & & & & & & & & & \\\\ \\sum F_y = 0 = & -F_1sin(45) & & -F_3 & & -F_5sin(30) & & & & & & & & & -P_1\\\\ \\end{matrix} \\end{gather} Above is the force balance equation pair for node N5 . Below is a sketch of the force balance for node N6 , the two force equations (for the horizontal, x , direction and the vertical, y , direction) are listed below the figure. \\begin{gather} \\begin{matrix} \\sum F_x = 0 = & & & & -F_4 & & & & & F_9sin(45) & & & & & \\\\ \\sum F_y = 0 = & & & & & & & -F_7 & & -F_9cos(45) & & & & & P_2\\\\ \\end{matrix} \\end{gather} Above is the force balance equation pair for node N6 . System Integration - Assemble the Network Equations The CT principle of system integration (not listed above but a legitimate component) as part of algorithm development is to gather the equation pairs into a single system of linear equations. We will move the known loads to the right hand side and essentially construct the matrix equation \\mathbf{A}\\mathbf{x} = \\mathbf{b} . The system below is a matrix representation of the equation pairs with the forces moved to the right hand side \\mathbf{b} = RHS . \\begin{gather} \\begin{pmatrix} ~ & F_1 & F_2 & F_3 & F_4 & F_5 & F_6 & F_7 & F_8 & F_9 & A_x & A_y & B_y & | & RHS\\\\ \\hline N1_x & 0.707 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & | & 0\\\\ N1_y & 0.707 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & | & 0\\\\ N2_x & 0 & -1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & | & 0\\\\ N2_y & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & | & 0\\\\ N3_x & 0 & 0 & 0 & 0 & -0.866 & -1 & 0 & 1 & 0 & 0 & 0 & 0 & | & 0\\\\ N3_y & 0 & 0 & 0 & 0 & 0.5 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & | & P_3\\\\ N4_x & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & -0.707 & 0 & 0 & 0 & | & 0\\\\ N4_y & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0.707 & 0 & 0 & 0 & | & 0\\\\ N5_x & -0.707 & 0 & 0 & 1 & 0.866 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & | & 0\\\\ N5_y & -0.707 & 0 & -1 & 0 & -0.5 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & | & P_1\\\\ N6_x & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0.707 & 0 & 0 & 0 & | & 0\\\\ N6_y & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & -0.707 & 0 & 0 & 0 & | & -P_2\\\\ \\end{pmatrix} \\end{gather} In the system, the rows are labeled on the left-most column with their node-related equation name. Thus each row of the matrix corresponds to an equation derived from a node. The columns are labeled with their respective unknown force (except the last column, which represents the right-hand-side of the system of linear equations). Thus the coefficient in each column corresponds to a force in each node equation. The sign of the coefficient refers to the assumed direction the force acts. In the analysis all the members were assumed to be in tension (except for the reaction forces). If a coefficient has a value of zero in a particular row, then that force does no act at the node to which the row corresponds. From this representation the transition to the formal vector-matrix representation is straightforward. First the coefficient matrix that is the result of the decomposition and node-by-node analysis. \\begin{gather} \\mathbf{A} = \\begin{pmatrix} 0.707 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\\\ 0.707 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\\\ 0 & -1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & -0.866 & -1 & 0 & 1 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0.5 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & -0.707 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0.707 & 0 & 0 & 0 \\\\ -0.707 & 0 & 0 & 1 & 0.866 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ -0.707 & 0 & -1 & 0 & -0.5 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0.707 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & -0.707 & 0 & 0 & 0 \\\\ \\end{pmatrix} \\end{gather} Then the vector (numpy array) of unknowns that are identified by decomposition and node-by-node analysis. \\begin{gather} \\mathbf{x} = \\begin{pmatrix} F_1\\\\ F_2\\\\ F_3\\\\ F_4\\\\ F_5\\\\ F_6\\\\ F_7\\\\ F_8\\\\ F_9\\\\ A_x\\\\ A_y\\\\ B_y\\\\ \\end{pmatrix} \\end{gather} And the right-hand side of forcing values, in this case three non-zero values \\begin{gather} \\mathbf{b} = \\begin{pmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ P_3\\\\ 0\\\\ 0\\\\ 0\\\\ P_1\\\\ 0\\\\ -P_2\\\\ \\end{pmatrix} \\end{gather} Algorithm (Initial Steps) The supervisory algorithm at this point is straightforward, we want to solve \\begin{equation} \\mathbf{A} \\cdot \\mathbf{x} =\\mathbf{b} \\end{equation} for \\begin{equation} \\mathbf{x} \\end{equation} The various matrices above are entered into text files named A.txt and B.txt, we can examine the file contents using the # list contents of the A matrix, uses call to OS host (replace `cat` with `type` if on a windoze Machine) !(cat A.txt) 0.707106781 1 0 0 0 0 0 0 0 1 0 0 0.707106781 0 0 0 0 0 0 0 0 0 1 0 0 -1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 -0.866 -1 0 1 0 0 0 0 0 0 0 0 0.5 0 1 0 0 0 0 0 0 0 0 0 0 0 0 -1 -0.707106781 0 0 0 0 0 0 0 0 0 0 0 0.707106781 0 0 1 -0.707106781 0 0 1 0.866 0 0 0 0 0 0 0 -0.707106781 0 -1 0 -0.5 0 0 0 0 0 0 0 0 0 0 -1 0 0 0 0 0.707106781 0 0 0 0 0 0 0 0 0 -1 0 -0.707106781 0 0 0 # list contents of RHS (AKA b) vector !(cat B.txt) 0.0 0.0 0.0 0.0 0.0 500.0 0.0 0.0 0.0 1000.0 0.0 -500.0 Now we use our solver tools, import numpy # load the numpy module amatrix = [] # null list to store matrix reads bvector = [] # null list to store matrix reads rowNumA = 0 # a counter, needed to parse input files colNumA = 0 # a counter, needed to parse input files rowNumB = 0 # a counter, needed to parse input files afile = open(\"A.txt\",\"r\") # connect and read file for MATRIX A for line in afile: amatrix.append([float(n) for n in line.strip().split()]) rowNumA += 1 afile.close() # Disconnect the file afile = open(\"B.txt\",\"r\") # connect and read file for VECTOR B for line in afile: bvector.append(float(line)) # vector read different -- just float the line rowNumB += 1 afile.close() # Disconnect the file A = numpy.array(amatrix) # create A b = numpy.array(bvector) # create b x = numpy.linalg.solve(A, b) # solve for x for i in range(0,len(x)): # rudimentary output print(x[i]) -1035.2710218174145 732.0471596998927 0.0 -267.9528403001072 -535.9056806002143 732.0471596998927 767.9528403001071 267.95284030010714 -378.94254092877543 -3.9202487786118276e-14 732.0471596998927 267.95284030010714 Algorithm (Refinement) To refine the algorithm, the obvious step is to label the output labels =['F1','F2','F3','F4','F5','F6','F7','F8','F9','Ax','Ay','By'] #a list of labels, should automate as needed for i in range(0,len(x)): # rudimentary output print(labels[i],\" = \",round(x[i],3),' pounds(force)') F1 = -1035.271 pounds(force) F2 = 732.047 pounds(force) F3 = 0.0 pounds(force) F4 = -267.953 pounds(force) F5 = -535.906 pounds(force) F6 = 732.047 pounds(force) F7 = 767.953 pounds(force) F8 = 267.953 pounds(force) F9 = -378.943 pounds(force) Ax = -0.0 pounds(force) Ay = 732.047 pounds(force) By = 267.953 pounds(force) Conclusion/Suggested Extensions Modify the analysis so forces at nodes are not necessary vertical, also include forces at all nodes (even zero valued) so can analyze any conditions for the truss Extend the size several more panels both directions so can approximate internal forces in a homogeneous beam (advanced). Mention that material properties (and knowledge of node coordinates, allows solutions for indeterminate cases (this is covered in another class)) References Johnson, J. (2020). Python Numpy Tutorial (with Jupyter and Colab). Retrieved September 15, 2020, from https://cs231n.github.io/python-numpy-tutorial/ Willems, K. (2019). (Tutorial) Python NUMPY Array TUTORIAL. Retrieved September 15, 2020, from https://www.datacamp.com/community/tutorials/python-numpy-tutorial?utm_source=adwords_ppc Willems, K. (2017). NumPy Cheat Sheet: Data Analysis in Python. Retrieved September 15, 2020, from https://www.datacamp.com/community/blog/python-numpy-cheat-sheet W3resource. (2020). NumPy: Compare two given arrays. Retrieved September 15, 2020, from https://www.w3resource.com/python-exercises/numpy/python-numpy-exercise-28.php Sorting https://www.programiz.com/python-programming/methods/list/sort Overland, B. (2018). Python Without Fear. Addison-Wesley ISBN 978-0-13-468747-6. Grus, Joel (2015). Data Science from Scratch: First Principles with Python O\u2019Reilly Media. Kindle Edition. Precord, C. (2010) wxPython 2.8 Application Development Cookbook Packt Publishing Ltd. Birmingham , B27 6PA, UK ISBN 978-1-849511-78-0. # Preamble script block to identify host, user, and kernel import sys ! hostname ! whoami print(sys.executable) print(sys.version) print(sys.version_info) atomickitty compthink /opt/jupyterhub/bin/python3 3.8.5 (default, Jul 28 2020, 12:59:40) [GCC 9.3.0] sys.version_info(major=3, minor=8, micro=5, releaselevel='final', serial=0)","title":"Statics"},{"location":"statics/statics/#making-an-ordinary-homework-problem-into-a-computational-thinking-exercise","text":"","title":"Making an ordinary homework problem into a computational thinking exercise"},{"location":"statics/statics/#engineering-mechanics-statics","text":"","title":"Engineering Mechanics (Statics)"},{"location":"statics/statics/#prerequesites-for-this-example","text":"Students will have completed ENGR-1330; CE 2301; and be enrolled in CE 2301 Students (by virtue of ENGR-1330) will have functioning implementations of JupyterLab","title":"Prerequesites (for this example)"},{"location":"statics/statics/#methodology-for-problem-and-solution","text":"Present problem verbatim from usual source, i.e. textbook Review main principles of CT : Algorithm - A list of steps that you can follow to finish a task Decomposition - Break a problem down into smaller pieces Abstraction - Pulling out specific differences to make one solution work for multiple problems Pattern Matching - Finding similarities between things CT Problem Solving Protocol (from ENGR-1330) Explicitly state the problem State: Input information Governing equations or principles, and The required output information. Work a sample problem by-hand for testing the general solution. Develop a general solution method (coding). Test the general solution against the by-hand example, then apply to the real problem. Start the problem/solution example; explicitly identify CT principles as problem proceedes. Choose meaningful problems A typical static truss analysis problem goes like \"The figure below is a simply supported, statically determinate truss with pin connections (zero moment transfer connections). Find the forces in each member for the loading shown.\" This example will leverage linear systems solver(s) to analyze the truss. The approach uses concepts from statics and computational thinking. From statics method of joints (for reactions and internal forcez) direction cosines From computational thinking read input file construct linear system \\textbf{Ax=b} ; solve for \\textbf{x} report results","title":"Methodology for Problem (and Solution)"},{"location":"statics/statics/#problem-solving-protocol","text":"Recall the problem solving protocols in ENGR-1330-S2021-Cleveland Define the problem (problem statement) Gather information (identify known and unknown values, and governing equations) Generate and evaluate potential solutions Refine and implement a solution Verify and test the solution. We can stipulate that Step 1 is already done,","title":"Problem Solving Protocol"},{"location":"statics/statics/#known-values","text":"Geometry (angles, not necessarily the mamber lengths and (x,y,z) coordinates of the junctions. External loads","title":"Known Values:"},{"location":"statics/statics/#unknown-values","text":"Support reactions Member forces","title":"Unknown Values"},{"location":"statics/statics/#governing-principles","text":"These are going to be problem and discipline specific; in this case two-force memebrs are assumed (stipulated), and the network is statically determinate. The ability to construct and find solutions to a non-singular linear system is assumed. The solution of linear systems is presented in ENGR-1330 in the following contexts: Linear Algebra using Numpy ENGR-1330-S2021-Cleveland Data Modeling: Regression Approach (Specifically, the later part of the lesson performs regression by solving linear systems entirely using python primatives) ENGR-1330-S2021-Cleveland Whatever students get in Calculus at this point","title":"Governing Principles"},{"location":"statics/statics/#abstraction-the-free-body-diagram","text":"Before even contemplating writing/using a program we need to build a mathematical model of the truss and assemble the system of linear equations that result from the model. A fundamental abstraction is to sketch a free-body-diagram as below and build a node naming convention (a type of pattern matching ) and force names( abstraction with intent to replicate/ automate ).","title":"Abstraction -- The Free-Body Diagram"},{"location":"statics/statics/#decomposition-node-by-node-analysis","text":"Next we will write the force balance for each of the six nodes ( N1 - N6 ), which will produce a total of 12 equations in the 12 unknowns (the 9 member forces, and 3 reactions). This is fundamentally a decomposition activity. While specific to this geometry, we could extend the analysis to allow for an external force at all nodes considered, and be able to solve for nearly any loading condition. The figure below is the force balance for node N1 , the two force equations (for the horizontal, x , direction and the vertical, y , direction) are listed below the figure. \\begin{gather} \\begin{matrix} \\sum F_x = 0 = & +F_1cos(45) & + F_2 & & & & & & & + A_x & & & & & \\\\ \\sum F_y = 0 = & +F_1sin(45) & & & & & & & & & & + A_y & & & \\\\ \\end{matrix} \\end{gather} The equation above is the force balance equation pair for the node. The x component equation will later be named N1_x to indicate it arises from Node 1, x component equation. A similar notation convention will also be adopted for the y component equation. There will be an equation pair for each node. Below is a sketch of the force balance for node N2 , the two force equations (for the horizontal, x , direction and the vertical, y , direction) are listed below the figure. \\begin{gather} \\begin{matrix} \\sum F_x = 0 = & & -F_2 & & & & +F_6 & & & & & & & & \\\\ \\sum F_y = 0 = & & & +F_3 & & & & & & & & & & & \\\\ \\end{matrix} \\end{gather} Below is a sketch of the force balance for node N3 , the two force equations (for the horizontal, x , direction and the vertical, y , direction) are listed below the figure. \\begin{gather} \\begin{matrix} \\sum F_x = 0 = & & & & & -F_5cos(30) & -F_6 & & +F_8 & & & & & & \\\\ \\sum F_y = 0 = & & & & & F_5sin(30) & & +F_7 & & & & & & & -P_3\\\\ \\end{matrix} \\end{gather} Above is the force balance equation pair for node N3 . Below is a sketch of the force balance for node N4 , the two force equations (for the horizontal, x , direction and the vertical, y , direction) are listed below the figure. \\begin{gather} \\begin{matrix} \\sum F_x = 0 = & & & & & & & & -F_8 & -F_9cos(45) & & & & & \\\\ \\sum F_y = 0 = & & & & & & & & & F_9sin(45) & & & +B_y & & \\\\ \\end{matrix} \\end{gather} Above is the force balance equation pair for node N4 . Below is a sketch of the force balance for node N5 , the two force equations (for the horizontal, x , direction and the vertical, y , direction) are listed below the figure. \\begin{gather} \\begin{matrix} \\sum F_x = 0 = & -F_1cos(45) & & & +F_4 & +F_5cos(30) & & & & & & & & & \\\\ \\sum F_y = 0 = & -F_1sin(45) & & -F_3 & & -F_5sin(30) & & & & & & & & & -P_1\\\\ \\end{matrix} \\end{gather} Above is the force balance equation pair for node N5 . Below is a sketch of the force balance for node N6 , the two force equations (for the horizontal, x , direction and the vertical, y , direction) are listed below the figure. \\begin{gather} \\begin{matrix} \\sum F_x = 0 = & & & & -F_4 & & & & & F_9sin(45) & & & & & \\\\ \\sum F_y = 0 = & & & & & & & -F_7 & & -F_9cos(45) & & & & & P_2\\\\ \\end{matrix} \\end{gather} Above is the force balance equation pair for node N6 .","title":"Decomposition -- Node-by-Node Analysis"},{"location":"statics/statics/#system-integration-assemble-the-network-equations","text":"The CT principle of system integration (not listed above but a legitimate component) as part of algorithm development is to gather the equation pairs into a single system of linear equations. We will move the known loads to the right hand side and essentially construct the matrix equation \\mathbf{A}\\mathbf{x} = \\mathbf{b} . The system below is a matrix representation of the equation pairs with the forces moved to the right hand side \\mathbf{b} = RHS . \\begin{gather} \\begin{pmatrix} ~ & F_1 & F_2 & F_3 & F_4 & F_5 & F_6 & F_7 & F_8 & F_9 & A_x & A_y & B_y & | & RHS\\\\ \\hline N1_x & 0.707 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & | & 0\\\\ N1_y & 0.707 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & | & 0\\\\ N2_x & 0 & -1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & | & 0\\\\ N2_y & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & | & 0\\\\ N3_x & 0 & 0 & 0 & 0 & -0.866 & -1 & 0 & 1 & 0 & 0 & 0 & 0 & | & 0\\\\ N3_y & 0 & 0 & 0 & 0 & 0.5 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & | & P_3\\\\ N4_x & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & -0.707 & 0 & 0 & 0 & | & 0\\\\ N4_y & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0.707 & 0 & 0 & 0 & | & 0\\\\ N5_x & -0.707 & 0 & 0 & 1 & 0.866 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & | & 0\\\\ N5_y & -0.707 & 0 & -1 & 0 & -0.5 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & | & P_1\\\\ N6_x & 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0.707 & 0 & 0 & 0 & | & 0\\\\ N6_y & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & -0.707 & 0 & 0 & 0 & | & -P_2\\\\ \\end{pmatrix} \\end{gather} In the system, the rows are labeled on the left-most column with their node-related equation name. Thus each row of the matrix corresponds to an equation derived from a node. The columns are labeled with their respective unknown force (except the last column, which represents the right-hand-side of the system of linear equations). Thus the coefficient in each column corresponds to a force in each node equation. The sign of the coefficient refers to the assumed direction the force acts. In the analysis all the members were assumed to be in tension (except for the reaction forces). If a coefficient has a value of zero in a particular row, then that force does no act at the node to which the row corresponds. From this representation the transition to the formal vector-matrix representation is straightforward. First the coefficient matrix that is the result of the decomposition and node-by-node analysis. \\begin{gather} \\mathbf{A} = \\begin{pmatrix} 0.707 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\\\ 0.707 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\\\ 0 & -1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & -0.866 & -1 & 0 & 1 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0.5 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & -0.707 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0.707 & 0 & 0 & 0 \\\\ -0.707 & 0 & 0 & 1 & 0.866 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ -0.707 & 0 & -1 & 0 & -0.5 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & -1 & 0 & 0 & 0 & 0 & 0.707 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0 & -0.707 & 0 & 0 & 0 \\\\ \\end{pmatrix} \\end{gather} Then the vector (numpy array) of unknowns that are identified by decomposition and node-by-node analysis. \\begin{gather} \\mathbf{x} = \\begin{pmatrix} F_1\\\\ F_2\\\\ F_3\\\\ F_4\\\\ F_5\\\\ F_6\\\\ F_7\\\\ F_8\\\\ F_9\\\\ A_x\\\\ A_y\\\\ B_y\\\\ \\end{pmatrix} \\end{gather} And the right-hand side of forcing values, in this case three non-zero values \\begin{gather} \\mathbf{b} = \\begin{pmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ P_3\\\\ 0\\\\ 0\\\\ 0\\\\ P_1\\\\ 0\\\\ -P_2\\\\ \\end{pmatrix} \\end{gather}","title":"System Integration - Assemble the Network Equations"},{"location":"statics/statics/#algorithm-initial-steps","text":"The supervisory algorithm at this point is straightforward, we want to solve \\begin{equation} \\mathbf{A} \\cdot \\mathbf{x} =\\mathbf{b} \\end{equation} for \\begin{equation} \\mathbf{x} \\end{equation} The various matrices above are entered into text files named A.txt and B.txt, we can examine the file contents using the # list contents of the A matrix, uses call to OS host (replace `cat` with `type` if on a windoze Machine) !(cat A.txt) 0.707106781 1 0 0 0 0 0 0 0 1 0 0 0.707106781 0 0 0 0 0 0 0 0 0 1 0 0 -1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 -0.866 -1 0 1 0 0 0 0 0 0 0 0 0.5 0 1 0 0 0 0 0 0 0 0 0 0 0 0 -1 -0.707106781 0 0 0 0 0 0 0 0 0 0 0 0.707106781 0 0 1 -0.707106781 0 0 1 0.866 0 0 0 0 0 0 0 -0.707106781 0 -1 0 -0.5 0 0 0 0 0 0 0 0 0 0 -1 0 0 0 0 0.707106781 0 0 0 0 0 0 0 0 0 -1 0 -0.707106781 0 0 0 # list contents of RHS (AKA b) vector !(cat B.txt) 0.0 0.0 0.0 0.0 0.0 500.0 0.0 0.0 0.0 1000.0 0.0 -500.0 Now we use our solver tools, import numpy # load the numpy module amatrix = [] # null list to store matrix reads bvector = [] # null list to store matrix reads rowNumA = 0 # a counter, needed to parse input files colNumA = 0 # a counter, needed to parse input files rowNumB = 0 # a counter, needed to parse input files afile = open(\"A.txt\",\"r\") # connect and read file for MATRIX A for line in afile: amatrix.append([float(n) for n in line.strip().split()]) rowNumA += 1 afile.close() # Disconnect the file afile = open(\"B.txt\",\"r\") # connect and read file for VECTOR B for line in afile: bvector.append(float(line)) # vector read different -- just float the line rowNumB += 1 afile.close() # Disconnect the file A = numpy.array(amatrix) # create A b = numpy.array(bvector) # create b x = numpy.linalg.solve(A, b) # solve for x for i in range(0,len(x)): # rudimentary output print(x[i]) -1035.2710218174145 732.0471596998927 0.0 -267.9528403001072 -535.9056806002143 732.0471596998927 767.9528403001071 267.95284030010714 -378.94254092877543 -3.9202487786118276e-14 732.0471596998927 267.95284030010714","title":"Algorithm (Initial Steps)"},{"location":"statics/statics/#algorithm-refinement","text":"To refine the algorithm, the obvious step is to label the output labels =['F1','F2','F3','F4','F5','F6','F7','F8','F9','Ax','Ay','By'] #a list of labels, should automate as needed for i in range(0,len(x)): # rudimentary output print(labels[i],\" = \",round(x[i],3),' pounds(force)') F1 = -1035.271 pounds(force) F2 = 732.047 pounds(force) F3 = 0.0 pounds(force) F4 = -267.953 pounds(force) F5 = -535.906 pounds(force) F6 = 732.047 pounds(force) F7 = 767.953 pounds(force) F8 = 267.953 pounds(force) F9 = -378.943 pounds(force) Ax = -0.0 pounds(force) Ay = 732.047 pounds(force) By = 267.953 pounds(force) Conclusion/Suggested Extensions Modify the analysis so forces at nodes are not necessary vertical, also include forces at all nodes (even zero valued) so can analyze any conditions for the truss Extend the size several more panels both directions so can approximate internal forces in a homogeneous beam (advanced). Mention that material properties (and knowledge of node coordinates, allows solutions for indeterminate cases (this is covered in another class))","title":"Algorithm (Refinement)"},{"location":"statics/statics/#references","text":"Johnson, J. (2020). Python Numpy Tutorial (with Jupyter and Colab). Retrieved September 15, 2020, from https://cs231n.github.io/python-numpy-tutorial/ Willems, K. (2019). (Tutorial) Python NUMPY Array TUTORIAL. Retrieved September 15, 2020, from https://www.datacamp.com/community/tutorials/python-numpy-tutorial?utm_source=adwords_ppc Willems, K. (2017). NumPy Cheat Sheet: Data Analysis in Python. Retrieved September 15, 2020, from https://www.datacamp.com/community/blog/python-numpy-cheat-sheet W3resource. (2020). NumPy: Compare two given arrays. Retrieved September 15, 2020, from https://www.w3resource.com/python-exercises/numpy/python-numpy-exercise-28.php Sorting https://www.programiz.com/python-programming/methods/list/sort Overland, B. (2018). Python Without Fear. Addison-Wesley ISBN 978-0-13-468747-6. Grus, Joel (2015). Data Science from Scratch: First Principles with Python O\u2019Reilly Media. Kindle Edition. Precord, C. (2010) wxPython 2.8 Application Development Cookbook Packt Publishing Ltd. Birmingham , B27 6PA, UK ISBN 978-1-849511-78-0. # Preamble script block to identify host, user, and kernel import sys ! hostname ! whoami print(sys.executable) print(sys.version) print(sys.version_info) atomickitty compthink /opt/jupyterhub/bin/python3 3.8.5 (default, Jul 28 2020, 12:59:40) [GCC 9.3.0] sys.version_info(major=3, minor=8, micro=5, releaselevel='final', serial=0)","title":"References"}]}